using System;
using Mapping_Tools.Annotations;
using Mapping_Tools.Classes.SystemTools;
using Newtonsoft.Json;
using System.ComponentModel;
using System.Linq;
using System.Reflection;
using Mapping_Tools.Classes.SnappingTools.DataStructure.RelevantObjectGenerators.GeneratorInputSelection;

namespace Mapping_Tools.Classes.SnappingTools.DataStructure.RelevantObjectGenerators {
    public class GeneratorSettings : BindableBase {
        [JsonIgnore]
        [CanBeNull]
        public RelevantObjectsGenerator Generator { get; set; }

        public GeneratorSettings() {
            _relevancyRatio = 0.8;
            _generatesInheritable = true;
            _inputPredicate = new SelectionPredicateCollection();
            _inputPredicate.Predicates.Add(new SelectionPredicate());
        }

        public GeneratorSettings(RelevantObjectsGenerator generator) {
            Generator = generator;

            _relevancyRatio = 0.8;
            _generatesInheritable = true;
        }

        private bool _isActive;
        [DisplayName("Active")]
        [Description("Active generators can generate virtual objects from hit objects or other virtual objects.")]
        public bool IsActive
        {
            get => _isActive;
            set => Set(ref _isActive, value);
        }

        private bool _isSequential;
        [DisplayName("Sequential")]
        [Description("Sequential generators will only take sequential objects as input.")]
        public bool IsSequential {
            get => _isSequential;
            set => Set(ref _isSequential, value);
        }

        private bool _isDeep;
        [DisplayName("Deep")]
        [Description("Deep generators can take objects as input not only from the previous layer, but all previous layers.")]
        public bool IsDeep {
            get => _isDeep;
            set => Set(ref _isDeep, value);
        }

        private double _relevancyRatio;
        [DisplayName("Relevancy Ratio")]
        [Description("The multiplier for the relevancy of virtual objects generated by this generator.")]
        public double RelevancyRatio {
            get => _relevancyRatio;
            set => Set(ref _relevancyRatio, value);
        }

        private bool _generatesInheritable;
        [DisplayName("Generates Inheritable")]
        [Description("Specifies whether virtual objects generated by this generator are inheritable.")]
        public bool GeneratesInheritable {
            get => _generatesInheritable;
            set => Set(ref _generatesInheritable, value);
        }

        private SelectionPredicateCollection _inputPredicate;
        [DisplayName("Input Selection")]
        [Description("Specifies extra rules that virtual objects need to obey to be used by this generator.")]
        public SelectionPredicateCollection InputPredicate {
            get => _inputPredicate;
            set => Set(ref _inputPredicate, value);
        }

        public void CopyTo(GeneratorSettings other) {
            var otherProperties = other.GetType().GetProperties();
            foreach (var prop in GetType().GetProperties()) {
                if (!prop.CanWrite || !prop.CanRead) continue;
                if (!otherProperties.Contains(prop)) continue;
                if (prop.GetCustomAttribute(typeof(JsonIgnoreAttribute)) != null) continue;
                if (prop.GetValue(this) is SelectionPredicateCollection s) {
                    Console.WriteLine("This");
                    Console.WriteLine(s.Predicates[0]);
                }
                if (prop.GetValue(other) is SelectionPredicateCollection d) {
                    Console.WriteLine("Other");
                    Console.WriteLine(d.Predicates[0]);
                }
                try { prop.SetValue(other, prop.GetValue(this)); } catch {
                    // ignored
                }
            }
        }

        public object Clone() {
            return MemberwiseClone();
        }
    }
}